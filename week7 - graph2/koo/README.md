# Week7 - graph2

## 1. 배달 (programmers 12978)

첫 시도는 간단하게 해보려고 그냥 정렬로 해봤습니다. 일종의 그리디 비슷하게 진행 했는데 역시나 틀렸습니다.  
다익스트라로 풀었습니다. heap을 사용해 간선의 무게가 가장 적은 것 부터 진행 할 수 있도록 했습니다.

## 2. 경주로 건설 (programmers 67259)

bfs를 활용해서 풀었습니다.  
다만 문제는 길이 만나는 점에서 당장은 값이 더 낮으나 이후 방향을 꺾게되어 더 높아지는 상황을 해결하기 어려웠습니다.  
DP를 활용하면 풀 수 있다는데 생각이 어려워 일단 bfs를 두 번 수행하는 방향으로 틀었습니다.

## 3. 전력망을 둘로 나누기 (programmers 86971)

처음엔 무슨 이런 문제가 있지 하고 당황했지만, wire를 하나씩 뺀 상태로 계산하는 방식으로 진행 했습니다.  
bfs를 구현해 노드가 연결되어 있다면 카운트 하는 방식으로 진행 했고, 두 무리의 카운트 차이를 구하는 방식으로 해결했습니다.

## 4. 가장 먼 노드 (programmers 49189)

bfs로 가장 먼 노드까지의 거리를 계산한 뒤, 해당 거리와 동일한 노드의 수를 세어주었습니다.  
후반 부 TC들이 시간이 조금 걸리던데 이를 줄일 수 있는 방법이 있는지는 생각해봐야 합니다.

## 5. 순위 (programmers 49191)

플로이드 워셜로 풀 수 있습니다.
삼중 for문을 돌려서 만약 한 선수를 거쳐 다른 선수의 순위가 파악 되는 요소가 있다면, 승패를 설정해 줍니다.  
이후 최종적으로 본인을 제외한 다른 이들과의 승패 관계를 파악할 수 있는 선수의 수를 구합니다.

## 6. 합승 택시 요금 (programmers 72413)

알고리즘을 막 엄청 복잡한 걸 쓴다기 보단 어떻게 적용할지 떠올리는게 어려운 듯 합니다.  
다익스트라를 노드별로 적용한 뒤, 특정 노드를 거쳐 가는 상황에서 최적의 값을 계산해 주면 됩니다.

## 7. 타겟 넘버 (programmers 43165)

재귀 함수를 활용해 더하고 빼기, 빼고 더하기 를 순서대로 계산해서 진행 했습니다.

## 8. 여행 경로 (programmers 43164)

최종 도착지를 먼저 선택하고 하나씩 진행해서 이후에 역순으로 결과를 내보내는 방식으로 진행 했습니다.
