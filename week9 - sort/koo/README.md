# Week8 - sort

## 1. 사라지는 발판 (programmers 92345)

발판이 사라집니다. 그렇게 저는 카카오에 가지 못했습니다.  
백트래킹 dfs를 이용하면 풀 수 있습니다.
`in_range`는 발판을 벗어나지 않았는지 확인하는 함수입니다.  
`is_finished`는 게임이 종료되었는지 확인하는 함수 입니다. 더 이상 갈 곳이 없을 때 종료되며, 같은 발판을 밟은 경우는 `solve` 함수에서 따로 처리해 줍니다.

`solve` 함수가 본체 입니다. 4방향 반복문을 돌며 dfs를 수행하게 되는데, 이때 `board`의 칸을 없앴다 다시 생성하며 백트래킹을 해야 합니다.  
재귀가 뱉어낸 값의 첫 번째 요소가 `False` 일 경우, 다음 차례에는 내가 무조건 승리함을 의미 합니다. 이 경우엔 최소 이동을 갱신 해줍니다.
만약 `False`가 아니고, 이길 수도 없는 상황 이라면 최대 이동을 갱신 해줍니다.

## 2. 광물 캐기 (programmers 172927)

분명 이노님이 쉽다고 했는데 애를 많이 먹은 광물 캐기 입니다.  
우선 전체 곡괭이의 수를 구한 뒤, `곡괭이의 수 * 5`개를 캘 수 있으므로 광물을 전처리 해줍니다.  
한 번 캘때, 5개를 캐므로 광물의 길이를 5로 나눈 몫에 하나를 더 한 길이의 list를 만듭니다. 이 list는 광물을 5개 씩 묶어주는 역할을 하며 `[dia의 수, iron의 수, stone의 수]`를 요소로 갖습니다.  
이후 dia, iron, stone의 순으로 정렬하되, 내림차순으로 정렬합니다. 이렇게 해야 피로도가 높은 광물 묶음을 먼저 처리할 수 있습니다.  
먼저 처리한다는 개념이 헷갈릴 수 있습니다. 왜냐햐면 광물은 순서대로 캔다고 적혀있기 때문입니다. 하지만 앞선 정렬 과정은 표면적으론 광물을 정렬하는 것 처럼 보이지만, 실제론 곡괭이를 정렬하는 것 입니다.  
이후 정렬된 list를 순차적으로 돌며, 사용할 수 있는 곡괭이 중 피로도가 적게 발생 하는 것부터 사용해주며 answer를 계산합니다.

## 4. merge sort

간만에 보는 병합 정렬입니다.
리스트를 요소 하나 남을때 까지 잘라 준 뒤, 쪼개진 리스트를 비교하며 정렬하면 됩니다.
