# DP
동적 계획법은 전체 문제를 한 번에 해결하는 것이 아니라, 작은 부분 문제들을 해결하고 이것들을 활용하여 전체 문제를 해결하는 방법이다. 그러나 작은 부분 문제를 통해 전체 문제를 해결했다고 해서 모두 DP로 문제를 해결했다고 볼 수 없다. 동적 계획법을 효율적으로 활용하려면 아래 두 가지 조건을 만족해야한다.

1. 큰 문제를 작은 문제로 나누었을 때 동일한 작은 문제가 반복해서 등장해야한다.
2. 큰 문제의 해결책은 작은 문제의 해결책의 합으로 구성할 수 있어야 한다.

DP는 divide conquer과는 다른데, divide conquer도 작은 부분 문제들을 통해 큰 문제를 해결한다는 점에서 같지만, DP는 **동일한 작은 문제들이 반복되는 경우**에 사용된다고 생각하면 된다.
```
-----------------------
|        Problem      |
-----------------------
/   \  /  \  /  \  /   \
| P1 || P2 || P3 || P4 |
```
다음과 같이 큰 문제인 **Problem**을 작게 P1, P2, P3, P4로 나누어 해결한 결과들을 합쳤을 때 문제가 해결되면, 이를 divide and conquer라고 한다. 또한 작은 문제의 해결책의 합으로 큰 문제를 해결할 수 있는 구조로 **최적 부분 구조(optimal substructure)**라고도 한다.

그러나 DP의 경우 작은 문제들이 반복해서 나타나는 현상이 있고, 이 반복된다는 특징을 이용하여 계속해서 문제를 해결해나가는 것이다.

```
-----------------------
|        Problem      |
-----------------------
/   \  /  \  /  \  /   \
| P1 || P2 || P1 || P3 |
```
DP의 경우 P1, P2, P1, P3으로 P1이 두 번 반복된 것을 볼 수 있다. 이 사실을 이용해서 P1이 반복되어 나오므로 그 결과를 기억하여 문제를 효율적으로 해결하는 것이다. 이 처럼 큰 문제를 나누었을 때 작은 문제가 여러 개 반복되는 문제를 **중복 부분 문제(overlapping subproblems)**이라고 한다.

**최적 부분 구조**와 **중복 부분 문제**가 동시에 발생하는 것이 바로 DP의 특성이다. 즉, 큰 문제를 잘게 쪼개어 작은 문제들을 해결하여 합치면 큰 문제가 해결되지만, 작은 문제들이 반복적으로 나오기 때문에 그 결과를 기억하여 효율적으로 해결하는 것이다.

## 점화식 세우기와 동적 계획법
동적 계획법으로 문제를 해결하는 절차는 다음과 같다.
1. 문제를 해결하는 해가 이미 있다고 가정하자.
2. 종료 조건을 설정한다.
3. 과정 1,2를 활용해 점화식을 세운다.

가장 대표적인 DP의 문제가 피보나치 수이다. 

먼저 피보나치 수 n를 해결하는 fibo(n)이 이미 있다고 가정하자. 다음으로 피보나치 수가 종료되는 조건은 n=1, n=2일 때로 이때는 무조건 1이다. 마지막으로 점화식으로 **fibo(n) = fibo(n-1) + fibo(n-2)**를 n=1, 2일 때 1이라는 종료조건으로 세운다.

`fibo(n)`을 구한다고 하자. `fibo(n) = fibo(n-1) + fibo(n-2)`이다. 그렇다면 재귀적으로 `fibo(n-1)`과 `fibo(n-2)`를 구해야하는데, 생각해보면 `fibo(n-1)`은 `fibo(n-2) + fibo(n-3)`이므로 `fibo(n-2)`가 중복된다. 즉, 이 작은 부분 문제들 사이에서 반복해서 발생하는 결과들이 있다는 것이다. 이를 참고하여 `fibo(n-2)`를 이전에 구했다면 새로 구할 것이 아니라, `fibo(n-2)`의 값을 기억해놓았다가 바로 쓰면 된다는 것이다. 

이렇게 부분 문제들의 결과를 기억하여 다시 사용하는 것을 **메모이제이션(memoization)**이라고 한다. 

가령, fibo(5)를 구한다고 하자. 문제를 해결하는 순서는 다음과 같이 된다.
1. fibo(5) = fibo(4) + fibo(3)
2. fibo(4) = fibo(3) + fibo(2)
3. fibo(3) = fibo(2) + fibo(1) 
4. fibo(2)와 fibo(1)은 1이다. 따라서 fibo(3)은 2이다.
5. 저장소에 fibo(3)은 2라는 것을 기억하도록 하자. `{3: 2}`
6. fibo(4)를 구할 때의 fibo(3)은 저장소의 값을 이용하면 된다. 따라서, 2 + 1 = 3 이 된다.
7. fibo(4)의 결과를 저장소에 저장하자, `{3:2, 4:3}`
8. fibo(5)를 구할 때, 저장소의 fibo(4)와 fibo(3) 값을 이용하자, 따라서 2 + 3 = 5가 된다.
9. 저장소에 fibo(5) 결과를 저장한다. `{3:2, 4:3, 5:5}`

만약 여기서 추가적으로 fibo(6)을 구하라고 한다면, `fibo(6) = fibo(5) + fibo(4)` 이므로 저장소에 있는 값을 그대로 써서 바로 `fibo(6)`은 5 + 3 = 8이라는 것을 알 수 있다.

이렇게 작은 부분 문제들을 해결하여 저장소에 기억하고 효율적으로 해결하는 것이 바로 **메모이제이션**이다. 

## 최장 증가 부분 수열(LIS)
부분 수열은 주어진 수열 중 일부를 뽑아 새로 만든 수열을 말한다. 이때 각각의 원소는 선후 관계를 유지해야한다.
```
i  :   0  1  2  3  4  5  6  7
arr: [ 1, 4, 2, 3, 1, 5, 7, 3]
```

다음의 수열이 있에서 `2,3,1,7`을 뽑으면 이것은 부분 수열이 된다.
```
i  :   0  1  2  3  4  5  6  7
arr: [ 1, 4, 2, 3, 1, 5, 7, 3]

i  :   0  1  2  3
arr: [ 2, 3, 1, 7]
```
이 중 최장 증가 부분 수열이라는 것은 수열의 원소가 오름차순을 유지하면서 길이가 가장 긴 수열의 길이를 말한다. 위의 경우는 `1,2,3,5,7`를 뽑으면 LIS(최장 증가 부분 수열)이 된다. 따라서 LIS는 5이다. 

LIS를 찾는 문제를 풀어보도록 하자. 일단 LIS의 특징을 생각해보면 다음과 같다.
1. 숫자가 점점 증가한다.
2. 원소 간의 전후 관계는 유지한다.

DP로 문제를 해결할 때는 반드시 문제를 잘게 쪼개는 것이 먼저라고 했다. `[1, 5, 2, 4]` 배열을 기준으로 생각해보도록 하자. 어떻게 문제를 잘게 쪼갤 지 모르겠다면 원소가 1개일 때를 생각해보자.

1. 원소가 1개일 때 `[1]`이면 `[1]`이므로 LIS는 1이다. 
2. 원소가 2개일 때 `[1,5]`이면 `[1,5]`이므로 LIS는 2이다.
3. 원소가 3개일 때 `[1,5,2]`이면 `[1,5]`, `[1,2]`이다. LIS는 2이다. 
4. 원소가 4개일 때 `[1,5,2,4]`이면 `[1,2,4]`이므로 LIS는 3이다. 

원소 4개일 때를 잘보자, `[1,2,4]`의 결과를 보면 `[1,2]`에 4를 추가한 것을 볼 수 있다. `[1,2]`는 원소가 3개일 때의 결과 중 하나이다. 원소가 3개일 때의 결과인 `[1,2]`도 잘 보면 원소가 1개 일 때인 `[1]`에 자신의 수인 2를 더해준 것이다. 

이를 통해서 알 수 있는 것은 작은 문제를 통해서 큰 문제를 해결할 수 있다는 것이다. 즉, **최적 부분 구조**라는 것을 알 수 있다. 또한, 계속해서 이전의 값들이 반복해서 다음의 값들을 계산할 때 쓰이는 것을 알 수 있다. 따라서 **중복 부분 문제**라는 것을 알 수 있다. 

`LIS(n)`이라는 답이 있다고 하자. `LIS(n)`의 맨 마지막 값은 `arr[n]`으로 끝나는 값이 된다. 그렇다면 `n`보다 작은 인덱스를 가진 `LIS`값들 중에서 가장 길이가 긴 값을 가진 결과에 +1을 한 값이 `LIS(n)`이 되는 것이다. 단, 이 값이 `LIS(k)`라고 한다면 `arr[n]`보다 `arr[k]`가 작아야한다.

위의 작은 문제들에서 나오는 패턴을 점화식으로 만들면 다음과 같다.
```
LIS(i) = max(k) + 1 (1 <= k < i) i,k는 인덱스이다.
LIS(1) = 1
```

예제를 통해서 확인해보도록 하자.
```
i  :   0  1  2  3  4  5  6  7
arr: [ 1, 4, 2, 3, 1, 5, 7, 3]

i  :   0  1  2  3  4  5  6  7
LIS: [ 0, 0, 0, 0, 0, 0, 0, 0]
```
위의 예제가 있다고 하자. 길이가 1일 때는 어차피 1이므로 LIS는 1이다.

```
i  :   0  1  2  3  4  5  6  7
arr: [ 1, 4, 2, 3, 1, 5, 7, 3]

i  :   0  1  2  3  4  5  6  7
LIS: [ 1, 0, 0, 0, 0, 0, 0, 0]
```

다음으로 `LIS(1)`을 구해보도록 하자. `LIS(1)`로 `LIS(0)`이 1이다. arr[0]은 1이고 arr[1]은 4이므로 `arr[0] < arr[1]`이다. 따라서, LIS(1) = LIS(0) + 1 = 2 이다.
```
i  :   0  1  2  3  4  5  6  7
arr: [ 1, 4, 2, 3, 1, 5, 7, 3]

i  :   0  1  2  3  4  5  6  7
LIS: [ 1, 2, 0, 0, 0, 0, 0, 0]
```

LIS(2)를 구해보도록 하자. LIS(0)=1, LIS(1)=2 이므로 LIS(1)이 가장 긴 값이다. 문제는 arr[1]이 4이므로 arr[2]보다 크다는 것이다. 따라서, LIS[1]은 안된다. LIS[0]의 경우는 arr[1]이 arr[2]보다 작으므로 LIS[2] = LIS(0) + 1 = 2가 된다.

```
i  :   0  1  2  3  4  5  6  7
arr: [ 1, 4, 2, 3, 1, 5, 7, 3]

i  :   0  1  2  3  4  5  6  7
LIS: [ 1, 2, 2, 0, 0, 0, 0, 0]
```
이처럼 이전의 값을 이용하여 새로운 값을 채워넣는 것이 바로 dp인 것이다.

계속해서 예제를 진행하면 다음과 같다.
```
i  :   0  1  2  3  4  5  6  7
arr: [ 1, 4, 2, 3, 1, 5, 7, 3]

i  :   0  1  2  3  4  5  6  7
LIS: [ 1, 2, 2, 0, 0, 0, 0, 0]
```
LIS[3] = LIS[2] + 1 (arr[2]가 arr[3]보다 작기 때문에) = 3이 된다. 

```
i  :   0  1  2  3  4  5  6  7
arr: [ 1, 4, 2, 3, 1, 5, 7, 3]

i  :   0  1  2  3  4  5  6  7
LIS: [ 1, 2, 2, 3, 0, 0, 0, 0]
```

마지막 7번째 값을 채울 때는 다음과 같이 된다.

```
i  :   0  1  2  3  4  5  6  7
arr: [ 1, 4, 2, 3, 1, 5, 7, 3]

i  :   0  1  2  3  4  5  6  7
LIS: [ 1, 2, 2, 3, 2, 4, 5, 0]
```
LIS[7]은 arr[7]이 3이기 때문에 LIS[2] + 1이다. 따라서 3이다.

```
i  :   0  1  2  3  4  5  6  7
arr: [ 1, 4, 2, 3, 1, 5, 7, 3]

i  :   0  1  2  3  4  5  6  7
LIS: [ 1, 2, 2, 3, 2, 4, 5, 3]
```
최종적으로 가장 긴 부분 수열은 5가 되는 것이다.

python으로 코드를 작성하면 다음과 같다.
```py
data = [1, 4, 2, 3, 1, 5, 7, 3] 
lis = []

def LIS(n, data, lis):
    if n == 0:
        return 1
    
    ret = 0
    for k in range(n):
        if data[k] < data[n] and ret < lis[k]:
            ret = lis[k]
    
    return ret + 1

for i in range(len(data)):
    lis.append(0)

max_val = 0
for i in range(len(data)):
    lis[i] = LIS(i, data, lis)
    if lis[i] > max_val:
        max_val = lis[i]
        
print("LIS:", lis) # LIS: [1, 2, 2, 3, 1, 4, 5, 3]
print("LEN:", max_val) # LEN: 5
```