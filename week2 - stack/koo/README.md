# Week2 - 스택

## 1. 괄호 회전하기 (programmers 76502)

이중 반복문으로 풀었습니다. 문제에 적힌 그대로 append와 pop 반복해서 구현 했습니다.

## 2. 짝지어 제거하기 (programmers 12973)

리스트를 반복문으로 돌리고 스택을 확인하면서 일치하면 pop 하는 식으로 해결 했습니다.

## 3. 주식 가격 (programmers 42584)

stack에 `[주식 가격, 순서]`를 추가해주며 진행 했습니다.  
만약 주식 가격이 이전과 비교해 낮아졌다면 현재 순서와 pop된 값의 순서의 차를 answer list에 업데이트 해주었습니다.  
while 반복문으로 가격이 하락하지 않을 때 까지 비교하도록 했습니다.

이후 stack이 비어 있지 않다면 최종 순서에서 pop된 값의 순서를 빼주며 answer list를 업데이트 했습니다.

## 4. 크레인 인형뽑기 게임 (programmers 64061)

moves를 돌면서 최대 depth 까지 반복문을 사용해 도달하도록 했습니다.  
만약 중간에 인형을 만난다면 depth 반복문은 빠져나오도록 했습니다.

이후엔 stack에 쌓인 인형을 비교해 제거하는 작업을 추가 했습니다.

## 5. 표 편집 (programmers 81303)

이번 문제 중 가장 어려웠습니다. 역시 카카오.  
다만 certi pro 시험을 준비하면서 링크드 리스트를 통해 요소를 다루는 시간을 획기적으로 줄일 수 있음을 깨달아서 방법은 금방 생각 났습니다.

저는 링크드 리스트를 구현하진 않고, 그냥 list를 `[앞 index, 뒤 index, 현재 index]`로 구성해서 풀었습니다. 대략 `[[0, 1, 0], [0, 2, 1], [1, 2, 2]]` 같은 구조가 되도록 했습니다. 이때, 가장 앞과 가장 뒤는 특수한 케이스로 각각 앞과 뒤가 본인인 것처럼 해서 예외 처리를 해주었습니다. 만약 가장 앞을 지우는 경우, `앞 index`와 `현재 index`가 같을 것이므로, `앞 index`에 대한 처리는 해줄 필요가 없게 했습니다.

`Z` 연산은 stack을 통해 구현 했습니다. stack엔 index를 저장 했고, 연산 수행 시 index를 통해 얻은 값의 앞 뒤 요소를 다시 index로 갱신 하도록 했습니다.

이동 연산에서 실수를 해서 좀 틀렸는데 split으로 써야 한다는 걸 뒤늦게 깨달았습니다. 처음엔 그냥 index를 지정해서 이동 횟수를 계산했는데 두 자리 수 이상으로 이동할 경우 문제가 생겼습니다. (40점 맞음;)

또 하나 문제는 O, X 표시 였습니다. str은 뭐 assignment가 안된다 어쩐다 하면서 에러 뿜뿜 하더니, 되는 방식으로 바꿔줘도 에러를 뿜더군요. 결국 list를 이용해 0, 1 값으로 지정한 뒤 다시 한 번 돌려서 0은 O, 1은 X와 매칭 되도록 만들었습니다.
