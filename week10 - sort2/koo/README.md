# Week10 - sort2

## 1. 문자열 내 마음대로 정렬하기 (programmers 12915)

특정 순서의 문자가 같은 경우를 해결하기 위해 전체 정렬을 해준 뒤, 정렬 기준을 lambda 함수로 정한 뒤 해결하면 되는 문제입니다.

## 2. 정수 내림차순으로 배치하기 (programmers 12933)

각 숫자들을 문자로 변환 후 list화 시킨 뒤, 내림차순 정렬 후 다시 정수로 변환해주면 되는 문제입니다.

## 3. K번째수 (programmers 42748)

반복문을 돌면서 주어진 조건대로만 코드를 작성하면 되는 문제 였습니다.

## 4. 가장 큰 수 (programmers 42746)

꽤 까다로웠는데요, 문자열의 정렬을 생각해야 했습니다.

문자열의 자리 수를 같게 한뒤 비교해주어야 어떤 수가 앞에 왔을때 더 큰 값을 만들 수 있는지 확인 할 수 있습니다.  
이를 위해선 각 숫자를 3번 이어 붙여야 합니다. 이는 숫자의 최대 크기가 1000 미만이라고 했기 때문입니다.

예시는 다음과 같습니다.

```
3   -> 333
31  -> 313(131)
310 -> 310(310310)
```

문자열은 아스키로 비교하기 때문에 가능한 방법입니다.

즉, 3번 이어 붙인 후 내림차순 정렬 후 이를 이어 붙인 값으로 반환 해주면 답을 구할 수 있습니다.

## 5. 튜플 (programmers 64065)

문제가 무슨 소린지 한참 봤습니다.  
결과적으로 주어진 집합은 순서가 뒤죽박죽 일 수 있지만, 원래의 튜플을 찾아내라는 것이었습니다.  
이는 `{{2}, {2, 1}}`일 경우 원래의 튜플은 `(2, 1)` 임을 의미하고, `{{1}, {2, 1}}`의 경우는 `(1, 2)`라는 얘기였습니다.
주어진 문자열을 괄호를 없앤 후 각 집합의 길이를 기준으로 오름차순 정렬을 합니다.  
이후 중복이 없다 했으므로, 정렬된 문자열을 하나씩 비교하며 result에 들어있는지 아닌지를 판단합니다.

## 6. 지형 이동 (programmers 62050)

어떻게 풀어야할지 몰라서 결국 참고를 했습니다. 풀이를 보고 감탄한 문제 입니다.  
heap을 사용한 풀이 입니다. heap은 pop을 할 경우 무조건 최소값을 반환하는데, 이를 cost로 정했습니다.  
사다리 없이 방문이 가능한 좌표의 cost는 0을 주고, 이를 모두 방문한 후엔 사다리를 설치 했을 경우 최소 비용으로 방문 가능한 좌표가 오게 됩니다.  
그 좌표에서 다시 사다리 없이 방문 가능한 좌표를 찾게 되고 동일한 과정이 반복됩니다. 방문한 좌표는 표시해두기에 중복은 발생하지 않습니다.
