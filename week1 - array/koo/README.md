# Week1 - 배열

## 1. 두 개 뽑아서 더하기 (68644)

한 번 실패 했는데 이유가 list의 범위를 잘못 선택했습니다.
첫 반복문을 돌 때는 list 전체 길이에서 최종적으로 하나 덜 가야 하고,
내부 반복문을 돌 때는 첫 반복문의 값 이후 index를 선택해야 합니다.

반복문 두 번 돌리고 answer list에 값이 없으면 append 하도록 짰습니다.
사실 set 쓰는게 더 빠를 것 같긴한데 기억이 안났습니다.

## 2. 모의고사 (42840)

패턴이 정해져 있어서 점수 확인은 쉬웠습니다.

오히려 누가 가장 많이 맞췄는지에서 좀 생각을 했는데 첫 번째 사람을 pivot 삼아,
index를 활용해서 score 비교 진행하는 식으로 해결했습니다.

## 3. 행렬의 곱셈 (12949)

행렬의 곱셈이 기억이 안납니다. 맞는지 헷갈려서 행렬의 곱셈 검색해봤는데 진짜 고등 수학 열심히 한거 다 어디갔는지...

무튼 앞에 오는 행렬의 열과 뒤에 오는 행렬의 행이 같으면 곱셈이 가능하다는 성질을 이용해 풀었습니다.

## 4. 실패율 (42889)

일단 첫 시도는 이중 반복문 이었는데 시간 초과는 안나지만 너무 많은 시간 소요가 있었고, 0으로 나누는 경우를 예외처리 하지 않아 런타임 에러도 있었습니다.

사무실에서 몰래 고민을 좀 했는데 결과적으론 리스트(`failure_stage`)를 하나 만들고 거기에 도달하지 못한 유저의 수를 기록해 두는 방식으로 진행했습니다. 그렇게 하면 stages의 길이만큼은 한 번만 돌아도 되기에 시간 복잡도 측면에서 나았습니다.

N 길이의 반복문을 돌게 했고 `temp`라는 분모를 선언했습니다. `temp`는 {전체 user 수(`user_num`) - 현재 스테이지 이전 까지 실패한 user 수(`failure_cnt`)}로 계산했습니다. 만약 `temp`가 0이라면 스테이지에 도달한 user가 없는 것이므로 반복문을 탈출하게 했습니다. 반복문을 진행하며 결과는 `answer_with_index`라는 리스트에 저장했고, 이는 `[실패율, index]`가 들어간 이중 리스트로 구성되어 있습니다.

이후엔 lambda를 이용해 정렬의 조건을 두 가지 설정해(실패율 내림 차순, index 오름차순), 앞서 계산된 결과를 저장한 `answer_with_index`를 정렬했습니다.
