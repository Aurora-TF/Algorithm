# Week4 - tree

## 3. 예상 대진표 (programmers 12985)

둘의 몫이 같아질 때 까지 계산하는 방식으로 해결했습니다. 1씩 더해서 나눠야 같은 라운드에서 대결했다는 것을 확인할 수 있습니다.

## 4. 다단계 칫솔 판매 (programmers 77486)

처음엔 `union find`로 풀어야 하는줄 알고 식겁했는데 그정도는 아니었습니다.  
각자의 부모를 `parent` list를 만들어 저장 해주고 반복문을 통해 상납 대상을 찾아 올라갔습니다.  
부모가 존재하지 않거나 더 이상 상납할 수 없을때 멈추도록 했습니다.

## 5. 미로 탈출 (programmers 159993)

bfs 쓰면 풀리는 문제 였는데, bfs 구현을 새까맣게 잊고 살았습니다.  
queue를 활용해서 다음 진행할 노드를 넣어주면서 bfs를 구현 했습니다.  
출발지에서 레버까지, 레버에서 도착지 까지 bfs를 적용해서 답을 구했습니다.

## 6. 양과 늑대 (programmers 92343)

카카오의 벽은 높았습니다.  
처음엔 자식 관계만 설정해준 뒤 순회하며 `bfs`를 활용하려 했습니다.  
다만 이전에 방문 했던 모든 노드를 또 방문할 수 있는 것에 대한 처리를 어떻게 할지 몰라서 실패 했습니다.

대신 `dfs`를 사용한 풀이가 있었는데요.  
visit으로 방문 여부를 확인합니다.

감탄 했던 점은 전체 edge를 다시 순회해서 이전에 방문 했을 지라도 자식 노드를 탐색하지 않았다면 다시 탐색하게 하는 부분 이었습니다.

`dfs`에서는 양이 늑대보다 더 많은 경우 일단 answer에 append 합니다.  
이후 부모 노드는 방문 했고 자식 노드는 방문하지 않았을 경우 탐색을 시작합니다.  
이 과정에서 `dfs` 재귀가 끝났다면 자식 노드 방문을 다시 초기화 합니다.

## 7. 길 찾기 게임 (programmers 42892)

tree를 구현하고 이후에 전위, 후위 순회를 진행 해주면 되는 문제였습니다.

idx를 추가한 node로 주어진 nodeinfo를 재구성 해준 뒤 `insert` 함수로 tree를 구현했습니다.  
tree는 dict를 활용해 구현했고 idx를 key로 가지며 value로는 [(x 좌표, y 좌표), 왼쪽 자식 노드 idx, 오른쪽 자식 노드 idx]로 구성되어있습니다.

이후에는 전위 순회 함수와 후위 순회 함수를 구현해서 해결했습니다.
